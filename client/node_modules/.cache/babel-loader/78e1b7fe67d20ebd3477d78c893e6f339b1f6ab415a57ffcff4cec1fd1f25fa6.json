{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { addNonReactiveToNamedFragments, hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, isFullyUnmaskedOperation, removeDirectivesFromDocument } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nvar QueryManager = /** @class */function () {\n  function QueryManager(options) {\n    var _this = this;\n    this.clientAwareness = {};\n    // All the queries that the QueryManager is currently managing (not\n    // including mutations and subscriptions).\n    this.queries = new Map();\n    // Maps from queryId strings to Promise rejection functions for\n    // currently active queries and fetches.\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    this.fetchCancelFns = new Map();\n    this.transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] || 2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1;\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    this.inFlightLinkObservables = new Trie(false);\n    this.noCacheWarningsByQueryId = new Set();\n    var defaultDocumentTransform = new DocumentTransform(function (document) {\n      return _this.cache.transformDocument(document);\n    },\n    // Allow the apollo cache to manage its own transform caches\n    {\n      cache: false\n    });\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    var documentTransform = options.documentTransform;\n    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform)\n    // The custom document transform may add new fragment spreads or new\n    // field selections, so we want to give the cache a chance to run\n    // again. For example, the InMemoryCache adds __typename to field\n    // selections and fragments from the fragment registry.\n    .concat(defaultDocumentTransform) : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n    if (this.onBroadcast = options.onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n  /**\r\n   * Call this method to terminate any active query processes, making it safe\r\n   * to dispose of this QueryManager instance.\r\n   */\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(newInvariantError(27));\n  };\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n  QueryManager.prototype.mutate = function (_a) {\n    return __awaiter(this, arguments, void 0, function (_b) {\n      var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n      var _c, _d;\n      var mutation = _b.mutation,\n        variables = _b.variables,\n        optimisticResponse = _b.optimisticResponse,\n        updateQueries = _b.updateQueries,\n        _e = _b.refetchQueries,\n        refetchQueries = _e === void 0 ? [] : _e,\n        _f = _b.awaitRefetchQueries,\n        awaitRefetchQueries = _f === void 0 ? false : _f,\n        updateWithProxyFn = _b.update,\n        onQueryUpdated = _b.onQueryUpdated,\n        _g = _b.fetchPolicy,\n        fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || \"network-only\" : _g,\n        _h = _b.errorPolicy,\n        errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || \"none\" : _h,\n        keepRootFields = _b.keepRootFields,\n        context = _b.context;\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            invariant(mutation, 28);\n            invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 29);\n            mutationId = this.generateMutationId();\n            mutation = this.cache.transformForLink(this.transform(mutation));\n            hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n            variables = this.getVariables(mutation, variables);\n            if (!hasClientExports) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\n          case 1:\n            variables = _j.sent();\n            _j.label = 2;\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n            isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {\n              mutationId: mutationId,\n              document: mutation,\n              variables: variables,\n              fetchPolicy: fetchPolicy,\n              errorPolicy: errorPolicy,\n              context: context,\n              updateQueries: updateQueries,\n              update: updateWithProxyFn,\n              keepRootFields: keepRootFields\n            });\n            this.broadcastQueries();\n            self = this;\n            return [2 /*return*/, new Promise(function (resolve, reject) {\n              return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: isOptimistic ? optimisticResponse : void 0\n              }), variables, {}, false), function (result) {\n                if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                  throw new ApolloError({\n                    graphQLErrors: getGraphQLErrorsFromResult(result)\n                  });\n                }\n                if (mutationStoreValue) {\n                  mutationStoreValue.loading = false;\n                  mutationStoreValue.error = null;\n                }\n                var storeResult = __assign({}, result);\n                if (typeof refetchQueries === \"function\") {\n                  refetchQueries = refetchQueries(storeResult);\n                }\n                if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                  delete storeResult.errors;\n                }\n                return self.markMutationResult({\n                  mutationId: mutationId,\n                  result: storeResult,\n                  document: mutation,\n                  variables: variables,\n                  fetchPolicy: fetchPolicy,\n                  errorPolicy: errorPolicy,\n                  context: context,\n                  update: updateWithProxyFn,\n                  updateQueries: updateQueries,\n                  awaitRefetchQueries: awaitRefetchQueries,\n                  refetchQueries: refetchQueries,\n                  removeOptimistic: isOptimistic ? mutationId : void 0,\n                  onQueryUpdated: onQueryUpdated,\n                  keepRootFields: keepRootFields\n                });\n              }).subscribe({\n                next: function (storeResult) {\n                  self.broadcastQueries();\n                  // Since mutations might receive multiple payloads from the\n                  // ApolloLink chain (e.g. when used with @defer),\n                  // we resolve with a SingleExecutionResult or after the final\n                  // ExecutionPatchResult has arrived and we have assembled the\n                  // multipart response into a single result.\n                  if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                    resolve(__assign(__assign({}, storeResult), {\n                      data: self.maskOperation({\n                        document: mutation,\n                        data: storeResult.data,\n                        fetchPolicy: fetchPolicy,\n                        id: mutationId\n                      })\n                    }));\n                  }\n                },\n                error: function (err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n                  if (isOptimistic) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n                  self.broadcastQueries();\n                  reject(err instanceof ApolloError ? err : new ApolloError({\n                    networkError: err\n                  }));\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n    var result = mutation.result;\n    var cacheWrites = [];\n    var skipCache = mutation.fetchPolicy === \"no-cache\";\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables\n        });\n      }\n      if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n        var diff = cache.diff({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true\n        });\n        var mergedData = void 0;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          result.data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables\n          });\n        }\n      }\n      var updateQueries_1 = mutation.updateQueries;\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n          var updater = updateQueries_1[queryName];\n          var _b = _this.queries.get(queryId),\n            document = _b.document,\n            variables = _b.variables;\n          // Read the current query result from the store.\n          var _c = cache.diff({\n              query: document,\n              variables: variables,\n              returnPartialData: true,\n              optimistic: false\n            }),\n            currentQueryResult = _c.result,\n            complete = _c.complete;\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            });\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n    }\n    if (cacheWrites.length > 0 || (mutation.refetchQueries || \"\").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n      var results_1 = [];\n      this.refetchQueries({\n        updateCache: function (cache) {\n          if (!skipCache) {\n            cacheWrites.forEach(function (write) {\n              return cache.write(write);\n            });\n          }\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          var update = mutation.update;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              var diff = cache.diff({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: _this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true\n              });\n              if (diff.complete) {\n                result = __assign(__assign({}, result), {\n                  data: diff.result\n                });\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables\n              });\n            }\n          }\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields: function (value, _a) {\n                var fieldName = _a.fieldName,\n                  DELETE = _a.DELETE;\n                return fieldName === \"__typename\" ? value : DELETE;\n              }\n            });\n          }\n        },\n        include: mutation.refetchQueries,\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null\n      }).forEach(function (result) {\n        return results_1.push(result);\n      });\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results_1).then(function () {\n          return result;\n        });\n      }\n    }\n    return Promise.resolve(result);\n  };\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables, {\n      IGNORE: IGNORE\n    }) : optimisticResponse;\n    if (data === IGNORE) {\n      return false;\n    }\n    this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        globalThis.__DEV__ !== false && invariant.error(error);\n      }\n    }, mutation.mutationId);\n    return true;\n  };\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchConcastWithInfo(this.getOrCreateQuery(queryId), options, networkStatus).concast.promise;\n  };\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n  QueryManager.prototype.transform = function (document) {\n    return this.documentTransform.transformDocument(document);\n  };\n  QueryManager.prototype.getDocumentInfo = function (document) {\n    var transformCache = this.transformCache;\n    if (!transformCache.has(document)) {\n      var cacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument([{\n          name: \"client\",\n          remove: true\n        }, {\n          name: \"connection\"\n        }, {\n          name: \"nonreactive\"\n        }, {\n          name: \"unmask\"\n        }], document),\n        defaultVars: getDefaultValues(getOperationDefinition(document)),\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: __assign(__assign({}, document), {\n          definitions: document.definitions.map(function (def) {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return __assign(__assign({}, def), {\n                operation: \"query\"\n              });\n            }\n            return def;\n          })\n        })\n      };\n      transformCache.set(document, cacheEntry);\n    }\n    return transformCache.get(document);\n  };\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n  };\n  QueryManager.prototype.watchQuery = function (options) {\n    var query = this.transform(options.query);\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(query, options.variables)\n    });\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n    var queryInfo = new QueryInfo(this);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    observable[\"lastQuery\"] = query;\n    if (!ObservableQuery[\"inactiveOnCreation\"].getValue()) {\n      this.queries.set(observable.queryId, queryInfo);\n    }\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables\n    });\n    return observable;\n  };\n  QueryManager.prototype.query = function (options, queryId) {\n    var _this = this;\n    if (queryId === void 0) {\n      queryId = this.generateQueryId();\n    }\n    invariant(options.query, 30);\n    invariant(options.query.kind === \"Document\", 31);\n    invariant(!options.returnPartialData, 32);\n    invariant(!options.pollInterval, 33);\n    var query = this.transform(options.query);\n    return this.fetchQuery(queryId, __assign(__assign({}, options), {\n      query: query\n    })).then(function (result) {\n      return result && __assign(__assign({}, result), {\n        data: _this.maskOperation({\n          document: query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id: queryId\n        })\n      });\n    }).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n  QueryManager.prototype.clearStore = function (options) {\n    if (options === void 0) {\n      options = {\n        discardWatches: true\n      };\n    }\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(newInvariantError(34));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n    // begin removing data from the store\n    return this.cache.reset(options);\n  };\n  QueryManager.prototype.getObservableQueries = function (include) {\n    var _this = this;\n    if (include === void 0) {\n      include = \"active\";\n    }\n    var queries = new Map();\n    var queryNames = new Map();\n    var queryNamesAndQueryStrings = new Map();\n    var legacyQueryOptions = new Set();\n    if (Array.isArray(include)) {\n      include.forEach(function (desc) {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          var queryString = print(_this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n    this.queries.forEach(function (_a, queryId) {\n      var oq = _a.observableQuery,\n        document = _a.document;\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n        var queryName = oq.queryName,\n          fetchPolicy = oq.options.fetchPolicy;\n        if (fetchPolicy === \"standby\" || include === \"active\" && !oq.hasObservers()) {\n          return;\n        }\n        if (include === \"active\" || queryName && queryNamesAndQueryStrings.has(queryName) || document && queryNamesAndQueryStrings.has(print(document))) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n          if (document) queryNamesAndQueryStrings.set(print(document), true);\n        }\n      }\n    });\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(function (options) {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        var queryInfo = _this.getOrCreateQuery(queryId).init({\n          document: options.query,\n          variables: options.variables\n        });\n        var oq = new ObservableQuery({\n          queryManager: _this,\n          queryInfo: queryInfo,\n          options: __assign(__assign({}, options), {\n            fetchPolicy: \"network-only\"\n          })\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n    if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach(function (included, nameOrQueryString) {\n        if (!included) {\n          var queryName = queryNames.get(nameOrQueryString);\n          if (queryName) {\n            globalThis.__DEV__ !== false && invariant.warn(35, queryName);\n          } else {\n            globalThis.__DEV__ !== false && invariant.warn(36);\n          }\n        }\n      });\n    }\n    return queries;\n  };\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n    var observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n      var fetchPolicy = observableQuery.options.fetchPolicy;\n      observableQuery.resetLastResults();\n      if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      (_this.queries.get(queryId) || observableQuery[\"queryInfo\"]).setDiff(null);\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n  QueryManager.prototype.startGraphQLSubscription = function (options) {\n    var _this = this;\n    var query = options.query,\n      variables = options.variables;\n    var fetchPolicy = options.fetchPolicy,\n      _a = options.errorPolicy,\n      errorPolicy = _a === void 0 ? \"none\" : _a,\n      _b = options.context,\n      context = _b === void 0 ? {} : _b,\n      _c = options.extensions,\n      extensions = _c === void 0 ? {} : _c;\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n    var makeObservable = function (variables) {\n      return _this.getObservableFromLink(query, context, variables, extensions).map(function (result) {\n        if (fetchPolicy !== \"no-cache\") {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: \"ROOT_SUBSCRIPTION\",\n              variables: variables\n            });\n          }\n          _this.broadcastQueries();\n        }\n        var hasErrors = graphQLResultHasError(result);\n        var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          var errors = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n          // `errorPolicy` is a mechanism for handling GraphQL errors, according\n          // to our documentation, so we throw protocol errors regardless of the\n          // set error policy.\n          if (errorPolicy === \"none\" || hasProtocolErrors) {\n            throw new ApolloError(errors);\n          }\n        }\n        if (errorPolicy === \"ignore\") {\n          delete result.errors;\n        }\n        return result;\n      });\n    };\n    if (this.getDocumentInfo(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n    return makeObservable(variables);\n  };\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n  QueryManager.prototype.removeQuery = function (queryId) {\n    var _a;\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      (_a = this.queries.get(queryId)) === null || _a === void 0 ? void 0 : _a.stop();\n      this.queries.delete(queryId);\n    }\n  };\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      var _a;\n      return (_a = info.observableQuery) === null || _a === void 0 ? void 0 : _a[\"notify\"]();\n    });\n  };\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, extensions,\n  // Prefer context.queryDeduplication if specified.\n  deduplication) {\n    var _this = this;\n    var _a;\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n    var observable;\n    var _b = this.getDocumentInfo(query),\n      serverQuery = _b.serverQuery,\n      clientQuery = _b.clientQuery;\n    if (serverQuery) {\n      var _c = this,\n        inFlightLinkObservables_1 = _c.inFlightLinkObservables,\n        link = _c.link;\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        })),\n        extensions: extensions\n      };\n      context = operation.context;\n      if (deduplication) {\n        var printedServerQuery_1 = print(serverQuery);\n        var varJson_1 = canonicalStringify(variables);\n        var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n        observable = entry.observable;\n        if (!observable) {\n          var concast_1 = new Concast([execute(link, operation)]);\n          observable = entry.observable = concast_1;\n          concast_1.beforeNext(function cb(method, arg) {\n            if (method === \"next\" && \"hasNext\" in arg && arg.hasNext) {\n              concast_1.beforeNext(cb);\n            } else {\n              inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n    return observable;\n  };\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n    var requestId = queryInfo.lastRequestId = this.generateRequestId();\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    var linkDocument = this.cache.transformForLink(options.query);\n    return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n      var graphQLErrors = getGraphQLErrorsFromResult(result);\n      var hasErrors = graphQLErrors.length > 0;\n      var errorPolicy = options.errorPolicy;\n      // If we interrupted this request by calling getResultsFromLink again\n      // with the same QueryInfo object, we ignore the old results.\n      if (requestId >= queryInfo.lastRequestId) {\n        if (hasErrors && errorPolicy === \"none\") {\n          // Throwing here effectively calls observer.error.\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: graphQLErrors\n          }));\n        }\n        // Use linkDocument rather than queryInfo.document so the\n        // operation/fragments used to write the result are the same as the\n        // ones used to obtain it from the link.\n        queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n        queryInfo.markReady();\n      }\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: NetworkStatus.ready\n      };\n      // In the case we start multiple network requests simulatenously, we\n      // want to ensure we properly set `data` if we're reporting on an old\n      // result which will not be caught by the conditional above that ends up\n      // throwing the markError result.\n      if (hasErrors && errorPolicy === \"none\") {\n        aqr.data = void 0;\n      }\n      if (hasErrors && errorPolicy !== \"ignore\") {\n        aqr.errors = graphQLErrors;\n        aqr.networkStatus = NetworkStatus.error;\n      }\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      });\n      // Avoid storing errors from older interrupted queries.\n      if (requestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n      throw error;\n    });\n  };\n  QueryManager.prototype.fetchConcastWithInfo = function (queryInfo, options,\n  // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus, query) {\n    var _this = this;\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n    if (query === void 0) {\n      query = options.query;\n    }\n    var variables = this.getVariables(query, options.variables);\n    var defaults = this.defaultOptions.watchQuery;\n    var _a = options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a,\n      _b = options.errorPolicy,\n      errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b,\n      _c = options.returnPartialData,\n      returnPartialData = _c === void 0 ? false : _c,\n      _d = options.notifyOnNetworkStatusChange,\n      notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n      _e = options.context,\n      context = _e === void 0 ? {} : _e;\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n    var fromVariables = function (variables) {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n      var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n      if (\n      // If we're in standby, postpone advancing options.fetchPolicy using\n      // applyNextFetchPolicy.\n      normalized.fetchPolicy !== \"standby\" &&\n      // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n      // this is another way to detect when nothing was done/fetched.\n      sourcesWithInfo.sources.length > 0 && queryInfo.observableQuery) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n      return sourcesWithInfo;\n    };\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    var cleanupCancelFn = function () {\n      return _this.fetchCancelFns.delete(queryInfo.queryId);\n    };\n    this.fetchCancelFns.set(queryInfo.queryId, function (reason) {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast, containsDataFromLink;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function (sourcesWithInfo) {\n        return sourcesWithInfo.sources;\n      }));\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      var sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n    return {\n      concast: concast,\n      fromLink: containsDataFromLink\n    };\n  };\n  QueryManager.prototype.refetchQueries = function (_a) {\n    var _this = this;\n    var updateCache = _a.updateCache,\n      include = _a.include,\n      _b = _a.optimistic,\n      optimistic = _b === void 0 ? false : _b,\n      _c = _a.removeOptimistic,\n      removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c,\n      onQueryUpdated = _a.onQueryUpdated;\n    var includedQueriesById = new Map();\n    if (include) {\n      this.getObservableQueries(include).forEach(function (oq, queryId) {\n        includedQueriesById.set(queryId, {\n          oq: oq,\n          lastDiff: (_this.queries.get(queryId) || oq[\"queryInfo\"]).getDiff()\n        });\n      });\n    }\n    var results = new Map();\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic: removeOptimistic,\n        onWatchUpdated: function (watch, diff, lastDiff) {\n          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n              var result = onQueryUpdated(oq, diff, lastDiff);\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result);\n              }\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, {\n                oq: oq,\n                lastDiff: lastDiff,\n                diff: diff\n              });\n            }\n          }\n        }\n      });\n    }\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(function (_a, queryId) {\n        var oq = _a.oq,\n          lastDiff = _a.lastDiff,\n          diff = _a.diff;\n        var result;\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = _this.cache.diff(oq[\"queryInfo\"][\"getDiffOptions\"]());\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n        if (result !== false) {\n          results.set(oq, result);\n        }\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          _this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n    return results;\n  };\n  QueryManager.prototype.maskOperation = function (options) {\n    var _a, _b, _c;\n    var document = options.document,\n      data = options.data;\n    if (globalThis.__DEV__ !== false) {\n      var fetchPolicy = options.fetchPolicy,\n        id = options.id;\n      var operationType = (_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation;\n      var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : \"o\") + id;\n      if (this.dataMasking && fetchPolicy === \"no-cache\" && !isFullyUnmaskedOperation(document) && !this.noCacheWarningsByQueryId.has(operationId)) {\n        this.noCacheWarningsByQueryId.add(operationId);\n        globalThis.__DEV__ !== false && invariant.warn(37, (_c = getOperationName(document)) !== null && _c !== void 0 ? _c : \"Unnamed \".concat(operationType !== null && operationType !== void 0 ? operationType : \"operation\"));\n      }\n    }\n    return this.dataMasking ? maskOperation(data, document, this.cache) : data;\n  };\n  QueryManager.prototype.maskFragment = function (options) {\n    var data = options.data,\n      fragment = options.fragment,\n      fragmentName = options.fragmentName;\n    return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;\n  };\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a,\n  // The initial networkStatus for this fetch, most often\n  // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n  // or setVariables.\n  networkStatus) {\n    var _this = this;\n    var query = _a.query,\n      variables = _a.variables,\n      fetchPolicy = _a.fetchPolicy,\n      refetchWritePolicy = _a.refetchWritePolicy,\n      errorPolicy = _a.errorPolicy,\n      returnPartialData = _a.returnPartialData,\n      context = _a.context,\n      notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n    var oldNetworkStatus = queryInfo.networkStatus;\n    queryInfo.init({\n      document: query,\n      variables: variables,\n      networkStatus: networkStatus\n    });\n    var readCache = function () {\n      return queryInfo.getDiff();\n    };\n    var resultsFromCache = function (diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n      var data = diff.result;\n      if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n      var fromData = function (data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n      if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data || void 0);\n        });\n      }\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (errorPolicy === \"none\" && networkStatus === NetworkStatus.refetch && Array.isArray(diff.missing)) {\n        return fromData(void 0);\n      }\n      return fromData(data);\n    };\n    var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n    // Watched queries must opt into overwriting existing data on refetch,\n    // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n    : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1 /* CacheWriteBehavior.OVERWRITE */ : 2 /* CacheWriteBehavior.MERGE */;\n    var resultsFromLink = function () {\n      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n        query: query,\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              sources: [resultsFromCache(diff, queryInfo.markReady())]\n            };\n          }\n          if (returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n          if (diff.complete || returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())]\n        };\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"standby\":\n        return {\n          fromLink: false,\n          sources: []\n        };\n    }\n  };\n  QueryManager.prototype.getOrCreateQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId);\n  };\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign(__assign({}, this.defaultContext), newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n  return QueryManager;\n}();\nexport { QueryManager };","map":{"version":3,"names":["invariant","newInvariantError","equal","execute","addNonReactiveToNamedFragments","hasDirectives","isExecutionPatchIncrementalResult","isExecutionPatchResult","isFullyUnmaskedOperation","removeDirectivesFromDocument","canonicalStringify","getDefaultValues","getOperationDefinition","getOperationName","hasClientExports","graphQLResultHasError","getGraphQLErrorsFromResult","Observable","asyncMap","isNonEmptyArray","Concast","makeUniqueId","isDocumentNode","isNonNullObject","DocumentTransform","mergeIncrementalData","ApolloError","isApolloError","graphQLResultHasProtocolErrors","ObservableQuery","logMissingFieldErrors","NetworkStatus","isNetworkRequestInFlight","QueryInfo","shouldWriteResult","PROTOCOL_ERRORS_SYMBOL","print","hasOwnProperty","Object","prototype","IGNORE","create","Trie","AutoCleanedWeakCache","cacheSizes","maskFragment","maskOperation","QueryManager","options","_this","clientAwareness","queries","Map","fetchCancelFns","transformCache","queryIdCounter","requestIdCounter","mutationIdCounter","inFlightLinkObservables","noCacheWarningsByQueryId","Set","defaultDocumentTransform","document","cache","transformDocument","link","defaultOptions","queryDeduplication","localState","ssrMode","assumeImmutableResults","dataMasking","documentTransform","concat","defaultContext","onBroadcast","mutationStore","stop","forEach","_info","queryId","stopQueryNoBroadcast","cancelPendingFetches","error","cancel","clear","mutate","_a","_b","mutation","variables","optimisticResponse","updateQueries","_e","refetchQueries","_f","awaitRefetchQueries","updateWithProxyFn","update","onQueryUpdated","_g","fetchPolicy","_c","_h","errorPolicy","_d","keepRootFields","context","mutationId","generateMutationId","transformForLink","transform","getDocumentInfo","getVariables","addExportedVariables","_j","sent","mutationStoreValue","loading","isOptimistic","markMutationOptimistic","broadcastQueries","self","Promise","resolve","reject","getObservableFromLink","__assign","result","graphQLErrors","storeResult","errors","markMutationResult","removeOptimistic","subscribe","next","hasNext","data","id","err","networkError","cacheWrites","skipCache","push","dataId","query","incremental","diff","asQuery","optimistic","returnPartialData","mergedData","updateQueries_1","observableQuery","queryName","call","updater","get","currentQueryResult","complete","nextQueryResult","mutationResult","queryVariables","length","results_1","updateCache","write","isFinalResult","modify","fields","value","fieldName","DELETE","include","all","then","recordOptimisticTransaction","globalThis","__DEV__","fetchQuery","networkStatus","fetchConcastWithInfo","getOrCreateQuery","concast","promise","getQueryStore","store","info","resetErrors","queryInfo","undefined","has","cacheEntry","hasForcedResolvers","shouldForceResolvers","hasNonreactiveDirective","nonReactiveQuery","clientQuery","serverQuery","name","remove","defaultVars","definitions","map","def","kind","operation","set","watchQuery","notifyOnNetworkStatusChange","observable","queryManager","getValue","init","generateQueryId","pollInterval","finally","stopQuery","String","generateRequestId","stopQueryInStore","stopQueryInStoreNoBroadcast","clearStore","discardWatches","reset","getObservableQueries","queryNames","queryNamesAndQueryStrings","legacyQueryOptions","Array","isArray","desc","queryString","add","oq","hasObservers","size","setObservableQuery","included","nameOrQueryString","warn","reFetchObservableQueries","includeStandby","observableQueryPromises","resetLastResults","refetch","setDiff","startGraphQLSubscription","extensions","makeObservable","hasErrors","hasProtocolErrors","protocolErrors","observablePromise_1","observer","sub","unsubscribe","removeQuery","delete","getLocalState","deduplication","inFlightLinkObservables_1","operationName","prepareContext","forceFetch","printedServerQuery_1","varJson_1","entry","lookup","concast_1","beforeNext","cb","method","arg","of","runResolvers","remoteResult","getResultsFromLink","cacheWriteBehavior","requestId","lastRequestId","linkDocument","markError","markResult","markReady","aqr","ready","defaults","normalized","assign","fromVariables","sourcesWithInfo","fetchQueryByPolicy","sources","cleanupCancelFn","reason","setTimeout","containsDataFromLink","fromLink","includedQueriesById","lastDiff","getDiff","results","batch","onWatchUpdated","watch","watcher","indexOf","operationType","operationId","fragment","fragmentName","refetchWritePolicy","oldNetworkStatus","readCache","resultsFromCache","missing","fromData","partial","resolved","resultsFromLink","shouldNotify","newContext"],"sources":["C:\\bootcamp\\PICKFORD---LACE\\client\\node_modules\\@apollo\\src\\core\\QueryManager.ts"],"sourcesContent":["import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode } from \"graphql\";\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from \"@wry/equality\";\n\nimport type { ApolloLink, FetchResult } from \"../link/core/index.js\";\nimport { execute } from \"../link/core/index.js\";\nimport {\n  addNonReactiveToNamedFragments,\n  defaultCacheSizes,\n  hasDirectives,\n  isExecutionPatchIncrementalResult,\n  isExecutionPatchResult,\n  isFullyUnmaskedOperation,\n  removeDirectivesFromDocument,\n} from \"../utilities/index.js\";\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\n\nimport type {\n  ObservableSubscription,\n  ConcastSourcesArray,\n} from \"../utilities/index.js\";\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  getGraphQLErrorsFromResult,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n  DocumentTransform,\n} from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport {\n  ApolloError,\n  isApolloError,\n  graphQLResultHasProtocolErrors,\n} from \"../errors/index.js\";\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n  DefaultContext,\n} from \"./types.js\";\nimport type { LocalState } from \"./LocalState.js\";\n\nimport type { QueryStoreValue } from \"./QueryInfo.js\";\nimport {\n  QueryInfo,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from \"./QueryInfo.js\";\nimport type { ApolloErrorOptions } from \"../errors/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nimport type { IgnoreModifier } from \"../cache/core/types/common.js\";\nimport type { TODO } from \"../utilities/types/TODO.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst IGNORE: IgnoreModifier = Object.create(null);\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  nonReactiveQuery: DocumentNode;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\nimport type { DefaultOptions } from \"./ApolloClient.js\";\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nimport { maskFragment, maskOperation } from \"../masking/index.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\n\ninterface MaskFragmentOptions<TData> {\n  fragment: DocumentNode;\n  data: TData;\n  fragmentName?: string;\n}\n\ninterface MaskOperationOptions<TData> {\n  document: DocumentNode;\n  data: TData;\n  id: string;\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\nexport interface QueryManagerOptions<TStore> {\n  cache: ApolloCache<TStore>;\n  link: ApolloLink;\n  defaultOptions: DefaultOptions;\n  documentTransform: DocumentTransform | null | undefined;\n  queryDeduplication: boolean;\n  onBroadcast: undefined | (() => void);\n  ssrMode: boolean;\n  clientAwareness: Record<string, string>;\n  localState: LocalState<TStore>;\n  assumeImmutableResults: boolean;\n  defaultContext: Partial<DefaultContext> | undefined;\n  dataMasking: boolean;\n}\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n  public readonly defaultContext: Partial<DefaultContext>;\n  public readonly dataMasking: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor(options: QueryManagerOptions<TStore>) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.cache = options.cache;\n    this.link = options.link;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientAwareness = options.clientAwareness;\n    this.localState = options.localState;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    const documentTransform = options.documentTransform;\n    this.documentTransform =\n      documentTransform ?\n        defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || Object.create(null);\n\n    if ((this.onBroadcast = options.onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TContext extends Record<string, any>,\n    TCache extends ApolloCache<any>,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<\n    FetchResult<MaybeMasked<TData>>\n  > {\n    invariant(\n      mutation,\n      \"mutation option is required. You must specify your GraphQL document in the mutation option.\"\n    );\n\n    invariant(\n      fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\",\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = (await this.localState.addExportedVariables(\n        mutation,\n        variables,\n        context\n      )) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    const isOptimistic =\n      optimisticResponse &&\n      this.markMutationOptimistic<TData, TVariables, TContext, TCache>(\n        optimisticResponse,\n        {\n          mutationId,\n          document: mutation,\n          variables,\n          fetchPolicy,\n          errorPolicy,\n          context,\n          updateQueries,\n          update: updateWithProxyFn,\n          keepRootFields,\n        }\n      );\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n          },\n          variables,\n          {},\n          false\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n            throw new ApolloError({\n              graphQLErrors: getGraphQLErrorsFromResult(result),\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(\n              storeResult as FetchResult<Unmasked<TData>>\n            );\n          }\n\n          if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<TData, TVariables, TContext, TCache>({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: isOptimistic ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        }\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n            resolve({\n              ...storeResult,\n              data: self.maskOperation({\n                document: mutation,\n                data: storeResult.data,\n                fetchPolicy,\n                id: mutationId,\n              }) as any,\n            });\n          }\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (isOptimistic) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : (\n              new ApolloError({\n                networkError: err,\n              })\n            )\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables,\n        });\n      }\n      if (\n        isExecutionPatchIncrementalResult(result) &&\n        isNonEmptyArray(result.incremental)\n      ) {\n        const diff = cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        });\n        let mergedData;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          (result as FetchResult).data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables,\n          });\n        }\n      }\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result as FetchResult<Unmasked<TData>>,\n              queryName: (document && getOperationName(document)) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      (mutation.refetchQueries || \"\").length > 0 ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache) => {\n          if (!skipCache) {\n            cacheWrites.forEach((write) => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          const isFinalResult =\n            !isExecutionPatchResult(result) ||\n            (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...(result as FetchResult), data: diff.result };\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache as TCache, result as FetchResult<Unmasked<TData>>, {\n                context: mutation.context,\n                variables: mutation.variables,\n              });\n            }\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n      }).forEach((result) => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean;\n    }\n  ) {\n    const data =\n      typeof optimisticResponse === \"function\" ?\n        optimisticResponse(mutation.variables, { IGNORE })\n      : optimisticResponse;\n\n    if (data === IGNORE) {\n      return false;\n    }\n\n    this.cache.recordOptimisticTransaction((cache) => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>(\n          {\n            ...mutation,\n            result: { data },\n          },\n          cache\n        );\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n\n    return true;\n  }\n\n  public fetchQuery<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchConcastWithInfo(\n      this.getOrCreateQuery(queryId),\n      options,\n      networkStatus\n    ).concast.promise as TODO;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new AutoCleanedWeakCache<\n    DocumentNode,\n    TransformCacheEntry\n  >(\n    cacheSizes[\"queryManager.getDocumentInfo\"] ||\n      defaultCacheSizes[\"queryManager.getDocumentInfo\"]\n  );\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n            { name: \"unmask\" },\n          ],\n          document\n        ),\n        defaultVars: getDefaultValues(\n          getOperationDefinition(document)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): OperationVariables {\n    return {\n      ...this.getDocumentInfo(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<\n    T,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n    observable[\"lastQuery\"] = query;\n\n    if (!ObservableQuery[\"inactiveOnCreation\"].getValue()) {\n      this.queries.set(observable.queryId, queryInfo);\n    }\n\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId()\n  ): Promise<ApolloQueryResult<MaybeMasked<TData>>> {\n    invariant(\n      options.query,\n      \"query option is required. You must specify your GraphQL document \" +\n        \"in the query option.\"\n    );\n\n    invariant(\n      options.query.kind === \"Document\",\n      'You must wrap the query string in a \"gql\" tag.'\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      \"returnPartialData option only supported on watchQuery.\"\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      \"pollInterval option only supported on watchQuery.\"\n    );\n\n    const query = this.transform(options.query);\n\n    return this.fetchQuery<TData, TVars>(queryId, { ...options, query })\n      .then(\n        (result) =>\n          result && {\n            ...result,\n            data: this.maskOperation({\n              document: query,\n              data: result.data,\n              fetchPolicy: options.fetchPolicy,\n              id: queryId,\n            }),\n          }\n      )\n      .finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.queries.forEach((queryInfo) => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNames = new Map<string, string | null>();\n    const queryNamesAndQueryStrings = new Map<string, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          const queryString = print(this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n          (document && queryNamesAndQueryStrings.has(print(document)))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n          if (document) queryNamesAndQueryStrings.set(print(document), true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getOrCreateQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n        if (!included) {\n          const queryName = queryNames.get(nameOrQueryString);\n\n          if (queryName) {\n            invariant.warn(\n              `Unknown query named \"%s\" requested in refetchQueries options.include array`,\n              queryName\n            );\n          } else {\n            invariant.warn(\n              `Unknown anonymous query requested in refetchQueries options.include array`\n            );\n          }\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery, queryId) => {\n        const { fetchPolicy } = observableQuery.options;\n        observableQuery.resetLastResults();\n        if (\n          includeStandby ||\n          (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n        (this.queries.get(queryId) || observableQuery[\"queryInfo\"]).setDiff(\n          null\n        );\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startGraphQLSubscription<T = any>(\n    options: SubscriptionOptions\n  ): Observable<FetchResult<T>> {\n    let { query, variables } = options;\n    const {\n      fetchPolicy,\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {},\n    } = options;\n\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(query, context, variables, extensions).map(\n        (result) => {\n          if (fetchPolicy !== \"no-cache\") {\n            // the subscription interface should handle not sending us results we no longer subscribe to.\n            // XXX I don't think we ever send in an object with errors, but we might in the future...\n            if (shouldWriteResult(result, errorPolicy)) {\n              this.cache.write({\n                query,\n                result: result.data,\n                dataId: \"ROOT_SUBSCRIPTION\",\n                variables: variables,\n              });\n            }\n\n            this.broadcastQueries();\n          }\n\n          const hasErrors = graphQLResultHasError(result);\n          const hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n          if (hasErrors || hasProtocolErrors) {\n            const errors: ApolloErrorOptions = {};\n            if (hasErrors) {\n              errors.graphQLErrors = result.errors;\n            }\n            if (hasProtocolErrors) {\n              errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n            }\n\n            // `errorPolicy` is a mechanism for handling GraphQL errors, according\n            // to our documentation, so we throw protocol errors regardless of the\n            // set error policy.\n            if (errorPolicy === \"none\" || hasProtocolErrors) {\n              throw new ApolloError(errors);\n            }\n          }\n\n          if (errorPolicy === \"ignore\") {\n            delete result.errors;\n          }\n\n          return result;\n        }\n      );\n\n    if (this.getDocumentInfo(query).hasClientExports) {\n      const observablePromise = this.localState\n        .addExportedVariables(query, variables, context)\n        .then(makeObservable);\n\n      return new Observable<FetchResult<T>>((observer) => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          (observable) => (sub = observable.subscribe(observer)),\n          observer.error\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.queries.get(queryId)?.stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach((info) => info.observableQuery?.[\"notify\"]());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Trie<{\n    observable?: Observable<FetchResult<any>>;\n  }>(false);\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    extensions?: Record<string, any>,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>> | undefined;\n\n    const { serverQuery, clientQuery } = this.getDocumentInfo(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication,\n        }),\n        extensions,\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const printedServerQuery = print(serverQuery);\n        const varJson = canonicalStringify(variables);\n\n        const entry = inFlightLinkObservables.lookup(\n          printedServerQuery,\n          varJson\n        );\n\n        observable = entry.observable;\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>,\n          ]);\n          observable = entry.observable = concast;\n\n          concast.beforeNext(function cb(method, arg: FetchResult) {\n            if (method === \"next\" && \"hasNext\" in arg && arg.hasNext) {\n              concast.beforeNext(cb);\n            } else {\n              inFlightLinkObservables.remove(printedServerQuery, varJson);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>,\n        ]);\n      }\n    } else {\n      observable = new Concast([Observable.of({ data: {} } as FetchResult<T>)]);\n      context = this.prepareContext(context);\n    }\n\n    if (clientQuery) {\n      observable = asyncMap(observable, (result) => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<\n      WatchQueryOptions<TVars, TData>,\n      \"query\" | \"variables\" | \"context\" | \"fetchPolicy\" | \"errorPolicy\"\n    >\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables\n      ),\n\n      (result) => {\n        const graphQLErrors = getGraphQLErrorsFromResult(result);\n        const hasErrors = graphQLErrors.length > 0;\n        const { errorPolicy } = options;\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(\n              new ApolloError({\n                graphQLErrors,\n              })\n            );\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(\n            result,\n            linkDocument,\n            options,\n            cacheWriteBehavior\n          );\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        // In the case we start multiple network requests simulatenously, we\n        // want to ensure we properly set `data` if we're reporting on an old\n        // result which will not be caught by the conditional above that ends up\n        // throwing the markError result.\n        if (hasErrors && errorPolicy === \"none\") {\n          aqr.data = void 0 as TData;\n        }\n\n        if (hasErrors && errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      (networkError) => {\n        const error =\n          isApolloError(networkError) ? networkError : (\n            new ApolloError({ networkError })\n          );\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      }\n    );\n  }\n\n  private fetchConcastWithInfo<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n    query = options.query\n  ): ConcastAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVars;\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const sourcesWithInfo = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        sourcesWithInfo.sources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options\n        );\n      }\n\n      return sourcesWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryInfo.queryId);\n    this.fetchCancelFns.set(queryInfo.queryId, (reason) => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    let concast: Concast<ApolloQueryResult<TData>>,\n      containsDataFromLink: boolean;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(\n        this.localState\n          .addExportedVariables(\n            normalized.query,\n            normalized.variables,\n            normalized.context\n          )\n          .then(fromVariables)\n          .then((sourcesWithInfo) => sourcesWithInfo.sources)\n      );\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return {\n      concast,\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache<TStore>,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<\n      string,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: (this.queries.get(queryId) || oq[\"queryInfo\"]).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloQueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = this.cache.diff(oq[\"queryInfo\"][\"getDiffOptions\"]());\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private noCacheWarningsByQueryId = new Set<string>();\n\n  public maskOperation<TData = unknown>(\n    options: MaskOperationOptions<TData>\n  ): MaybeMasked<TData> {\n    const { document, data } = options;\n\n    if (__DEV__) {\n      const { fetchPolicy, id } = options;\n      const operationType = getOperationDefinition(document)?.operation;\n      const operationId = (operationType?.[0] ?? \"o\") + id;\n\n      if (\n        this.dataMasking &&\n        fetchPolicy === \"no-cache\" &&\n        !isFullyUnmaskedOperation(document) &&\n        !this.noCacheWarningsByQueryId.has(operationId)\n      ) {\n        this.noCacheWarningsByQueryId.add(operationId);\n\n        invariant.warn(\n          '[%s]: Fragments masked by data masking are inaccessible when using fetch policy \"no-cache\". Please add `@unmask` to each fragment spread to access the data.',\n          getOperationName(document) ??\n            `Unnamed ${operationType ?? \"operation\"}`\n        );\n      }\n    }\n\n    return (\n      this.dataMasking ?\n        maskOperation(data, document, this.cache)\n      : data) as MaybeMasked<TData>;\n  }\n\n  public maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>) {\n    const { data, fragment, fragmentName } = options;\n\n    return this.dataMasking ?\n        maskFragment(data, fragment, this.cache, fragmentName)\n      : data;\n  }\n\n  private fetchQueryByPolicy<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    {\n      query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus\n  ): SourcesAndInfo<TData> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff();\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) =>\n        Observable.of({\n          data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          ...(diff.complete ? null : { partial: true }),\n        } as ApolloQueryResult<TData>);\n\n      if (data && this.getDocumentInfo(query).hasForcedResolvers) {\n        return this.localState\n          .runResolvers({\n            document: query,\n            remoteResult: { data },\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n          })\n          .then((resolved) => fromData(resolved.data || void 0));\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        Array.isArray(diff.missing)\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID\n        // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n      : (\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ?\n        CacheWriteBehavior.OVERWRITE\n      : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, cacheWriteBehavior, {\n        query,\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            sources: [resultsFromCache(diff, queryInfo.markReady())],\n          };\n        }\n\n        if (returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n        };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"standby\":\n        return { fromLink: false, sources: [] };\n    }\n  }\n\n  public getOrCreateQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...this.defaultContext,\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface FetchConcastInfo {\n  // Metadata properties that can be returned in addition to the Concast.\n  fromLink: boolean;\n}\ninterface SourcesAndInfo<TData> extends FetchConcastInfo {\n  sources: ConcastSourcesArray<ApolloQueryResult<TData>>;\n}\ninterface ConcastAndInfo<TData> extends FetchConcastInfo {\n  concast: Concast<ApolloQueryResult<TData>>;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}