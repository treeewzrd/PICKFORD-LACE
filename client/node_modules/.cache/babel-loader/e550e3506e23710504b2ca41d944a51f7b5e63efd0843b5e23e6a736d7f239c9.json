{"ast":null,"code":"import { Kind } from \"graphql\";\nimport { getFragmentMaskMode, maybeDeepFreeze, resultKeyNameFromField } from \"../utilities/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nexport function maskDefinition(data, selectionSet, context) {\n  return disableWarningsSlot.withValue(true, function () {\n    var masked = maskSelectionSet(data, selectionSet, context, false);\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\nfunction getMutableTarget(data, mutableTargets) {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n  var mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\nfunction maskSelectionSet(data, selectionSet, context, migration, path) {\n  var _a;\n  var knownChanged = context.knownChanged;\n  var memo = getMutableTarget(data, context.mutableTargets);\n  if (Array.isArray(data)) {\n    for (var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++) {\n      var _c = _b[_i],\n        index = _c[0],\n        item = _c[1];\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n      var masked = maskSelectionSet(item, selectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \"[\").concat(index, \"]\") : void 0);\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n      memo[index] = masked;\n    }\n    return knownChanged.has(memo) ? memo : data;\n  }\n  for (var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++) {\n    var selection = _e[_d];\n    var value = void 0;\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n    if (selection.kind === Kind.FIELD) {\n      var keyName = resultKeyNameFromField(selection);\n      var childSelectionSet = selection.selectionSet;\n      value = memo[keyName] || data[keyName];\n      if (value === void 0) {\n        continue;\n      }\n      if (childSelectionSet && value !== null) {\n        var masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \".\").concat(keyName) : void 0);\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n      if (!(globalThis.__DEV__ !== false)) {\n        memo[keyName] = value;\n      }\n      if (globalThis.__DEV__ !== false) {\n        if (migration && keyName !== \"__typename\" &&\n        // either the field is not present in the memo object\n        // or it has a `get` descriptor, not a `value` descriptor\n        // => it is a warning accessor and we can overwrite it\n        // with another accessor\n        !((_a = Object.getOwnPropertyDescriptor(memo, keyName)) === null || _a === void 0 ? void 0 : _a.value)) {\n          Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || \"\", context.operationName, context.operationType));\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {\n      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);\n    }\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      var fragmentName = selection.name.value;\n      var fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));\n      invariant(fragment, 47, fragmentName);\n      var mode = getFragmentMaskMode(selection);\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(data, fragment.selectionSet, context, mode === \"migrate\", path);\n      }\n    }\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n  return knownChanged.has(memo) ? memo : data;\n}\nfunction getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {\n  var getValue = function () {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n    globalThis.__DEV__ !== false && invariant.warn(48, operationName ? \"\".concat(operationType, \" '\").concat(operationName, \"'\") : \"anonymous \".concat(operationType), \"\".concat(path, \".\").concat(fieldName).replace(/^\\./, \"\"));\n    getValue = function () {\n      return value;\n    };\n    return value;\n  };\n  return {\n    get: function () {\n      return getValue();\n    },\n    set: function (newValue) {\n      getValue = function () {\n        return newValue;\n      };\n    },\n    enumerable: true,\n    configurable: true\n  };\n}","map":{"version":3,"names":["Kind","getFragmentMaskMode","maybeDeepFreeze","resultKeyNameFromField","disableWarningsSlot","invariant","maskDefinition","data","selectionSet","context","withValue","masked","maskSelectionSet","Object","isFrozen","getMutableTarget","mutableTargets","has","get","mutableTarget","Array","isArray","create","set","migration","path","knownChanged","memo","_i","_b","from","entries","length","_c","index","item","globalThis","__DEV__","concat","add","_d","_e","selections","selection","value","kind","FIELD","keyName","childSelectionSet","_a","getOwnPropertyDescriptor","defineProperty","getAccessorWarningDescriptor","operationName","operationType","INLINE_FRAGMENT","typeCondition","cache","fragmentMatches","__typename","FRAGMENT_SPREAD","fragmentName","name","fragment","fragmentMap","lookupFragment","mode","keys","fieldName","getValue","warn","replace","newValue","enumerable","configurable"],"sources":["C:\\bootcamp\\PICKFORD---LACE\\client\\node_modules\\@apollo\\src\\masking\\maskDefinition.ts"],"sourcesContent":["import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode, SelectionSetNode } from \"graphql\";\nimport {\n  getFragmentMaskMode,\n  maybeDeepFreeze,\n  resultKeyNameFromField,\n} from \"../utilities/index.js\";\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport type { ApolloCache } from \"../cache/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\n\ninterface MaskingContext {\n  operationType: \"query\" | \"mutation\" | \"subscription\" | \"fragment\";\n  operationName: string | undefined;\n  fragmentMap: FragmentMap;\n  cache: ApolloCache<unknown>;\n  mutableTargets: WeakMap<any, any>;\n  knownChanged: WeakSet<any>;\n}\n\nexport function maskDefinition(\n  data: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext\n) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\n\nfunction getMutableTarget(\n  data: Record<string, any>,\n  mutableTargets: WeakMap<any, any>\n): typeof data {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  const mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(\n  data: any,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext,\n  migration: boolean,\n  path?: string | undefined\n): typeof data {\n  const { knownChanged } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      const masked = maskSelectionSet(\n        item,\n        selectionSet,\n        context,\n        migration,\n        __DEV__ ? `${path || \"\"}[${index}]` : void 0\n      );\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (const selection of selectionSet.selections) {\n    let value: any;\n\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(\n          data[keyName],\n          childSelectionSet,\n          context,\n          migration,\n          __DEV__ ? `${path || \"\"}.${keyName}` : void 0\n        );\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (\n          migration &&\n          keyName !== \"__typename\" &&\n          // either the field is not present in the memo object\n          // or it has a `get` descriptor, not a `value` descriptor\n          // => it is a warning accessor and we can overwrite it\n          // with another accessor\n          !Object.getOwnPropertyDescriptor(memo, keyName)?.value\n        ) {\n          Object.defineProperty(\n            memo,\n            keyName,\n            getAccessorWarningDescriptor(\n              keyName,\n              value,\n              path || \"\",\n              context.operationName,\n              context.operationType\n            )\n          );\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (\n      selection.kind === Kind.INLINE_FRAGMENT &&\n      (!selection.typeCondition ||\n        context.cache.fragmentMatches!(selection, data.__typename))\n    ) {\n      value = maskSelectionSet(\n        data,\n        selection.selectionSet,\n        context,\n        migration,\n        path\n      );\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment: FragmentDefinitionNode | null =\n        context.fragmentMap[fragmentName] ||\n        (context.fragmentMap[fragmentName] =\n          context.cache.lookupFragment(fragmentName)!);\n      invariant(\n        fragment,\n        \"Could not find fragment with name '%s'.\",\n        fragmentName\n      );\n\n      const mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(\n          data,\n          fragment.selectionSet,\n          context,\n          mode === \"migrate\",\n          path\n        );\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(\n  fieldName: string,\n  value: any,\n  path: string,\n  operationName: string | undefined,\n  operationType: string\n): PropertyDescriptor {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    invariant.warn(\n      \"Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead.\",\n      operationName ?\n        `${operationType} '${operationName}'`\n      : `anonymous ${operationType}`,\n      `${path}.${fieldName}`.replace(/^\\./, \"\")\n    );\n\n    getValue = () => value;\n\n    return value;\n  };\n\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}