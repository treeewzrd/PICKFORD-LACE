{"ast":null,"code":"// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst {\n  forEach,\n  slice\n} = Array.prototype;\nconst {\n  hasOwnProperty\n} = Object.prototype;\nexport class Trie {\n  constructor() {\n    let weakness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let makeData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMakeData;\n    this.weakness = weakness;\n    this.makeData = makeData;\n  }\n  lookup() {\n    return this.lookupArray(arguments);\n  }\n  lookupArray(array) {\n    let node = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return hasOwnProperty.call(node, \"data\") ? node.data : node.data = this.makeData(slice.call(array));\n  }\n  peek() {\n    return this.peekArray(arguments);\n  }\n  peekArray(array) {\n    let node = this;\n    for (let i = 0, len = array.length; node && i < len; ++i) {\n      const map = node.mapFor(array[i], false);\n      node = map && map.get(array[i]);\n    }\n    return node && node.data;\n  }\n  remove() {\n    return this.removeArray(arguments);\n  }\n  removeArray(array) {\n    let data;\n    if (array.length) {\n      const head = array[0];\n      const map = this.mapFor(head, false);\n      const child = map && map.get(head);\n      if (child) {\n        data = child.removeArray(slice.call(array, 1));\n        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n          map.delete(head);\n        }\n      }\n    } else {\n      data = this.data;\n      delete this.data;\n    }\n    return data;\n  }\n  getChildTrie(key) {\n    const map = this.mapFor(key, true);\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));\n    return child;\n  }\n  mapFor(key, create) {\n    return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = new WeakMap() : void 0) : this.strong || (create ? this.strong = new Map() : void 0);\n  }\n}\nfunction isObjRef(value) {\n  switch (typeof value) {\n    case \"object\":\n      if (value === null) break;\n    // Fall through to return true...\n    case \"function\":\n      return true;\n  }\n  return false;\n}","map":{"version":3,"names":["defaultMakeData","Object","create","forEach","slice","Array","prototype","hasOwnProperty","Trie","constructor","weakness","arguments","length","undefined","makeData","lookup","lookupArray","array","node","call","key","getChildTrie","data","peek","peekArray","i","len","map","mapFor","get","remove","removeArray","head","child","weak","strong","size","delete","set","isObjRef","WeakMap","Map","value"],"sources":["C:\\Bootcamp\\mern-graphql-ecommerce\\client\\node_modules\\@wry\\trie\\src\\index.ts"],"sourcesContent":["// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\n\nexport class Trie<Data> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, Trie<Data>>;\n  private strong?: Map<any, Trie<Data>>;\n  private data?: Data;\n\n  constructor(\n    private weakness = true,\n    private makeData: (array: any[]) => Data = defaultMakeData,\n  ) {}\n\n  public lookup<T extends any[]>(...array: T): Data;\n  public lookup(): Data {\n    return this.lookupArray(arguments);\n  }\n\n  public lookupArray<T extends IArguments | any[]>(array: T): Data {\n    let node: Trie<Data> = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return hasOwnProperty.call(node, \"data\")\n      ? node.data as Data\n      : node.data = this.makeData(slice.call(array));\n  }\n\n  public peek<T extends any[]>(...array: T): Data | undefined;\n  public peek(): Data | undefined {\n    return this.peekArray(arguments);\n  }\n\n  public peekArray<T extends IArguments | any[]>(array: T): Data | undefined {\n    let node: Trie<Data> | undefined = this;\n\n    for (let i = 0, len = array.length; node && i < len; ++i) {\n      const map = node.mapFor(array[i], false);\n      node = map && map.get(array[i]);\n    }\n\n    return node && node.data;\n  }\n\n  public remove(...array: any[]): Data | undefined;\n  public remove(): Data | undefined {\n    return this.removeArray(arguments);\n  }\n\n  public removeArray<T extends IArguments | any[]>(array: T): Data | undefined {\n    let data: Data | undefined;\n\n    if (array.length) {\n      const head = array[0];\n      const map = this.mapFor(head, false);\n      const child = map && map.get(head);\n      if (child) {\n        data = child.removeArray(slice.call(array, 1));\n        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n          map.delete(head);\n        }\n      }\n    } else {\n      data = this.data;\n      delete this.data;\n    }\n\n    return data;\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.mapFor(key, true)!;\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie<Data>(this.weakness, this.makeData));\n    return child;\n  }\n\n  private mapFor(key: any, create: boolean): Trie<Data>[\"weak\" | \"strong\"] | undefined {\n    return this.weakness && isObjRef(key)\n      ? this.weak || (create ? this.weak = new WeakMap : void 0)\n      : this.strong || (create ? this.strong = new Map : void 0);\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}