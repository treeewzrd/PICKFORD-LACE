{"ast":null,"code":"import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet } from \"./helpers.js\";\nconst EntryMethods = {\n  setDirty: true,\n  dispose: true,\n  forget: true // Fully remove parent Entry from LRU cache and computation graph\n};\nexport function dep(options) {\n  const depsByKey = new Map();\n  const subscribe = options && options.subscribe;\n  function depend(key) {\n    const parent = parentEntrySlot.getValue();\n    if (parent) {\n      let dep = depsByKey.get(key);\n      if (!dep) {\n        depsByKey.set(key, dep = new Set());\n      }\n      parent.dependOn(dep);\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep);\n        dep.unsubscribe = subscribe(key);\n      }\n    }\n  }\n  depend.dirty = function dirty(key, entryMethodName) {\n    const dep = depsByKey.get(key);\n    if (dep) {\n      const m = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\";\n      // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n      // because modifying a Set while iterating over it can cause elements in\n      // the Set to be removed from the Set before they've been iterated over.\n      arrayFromSet(dep).forEach(entry => entry[m]());\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n  return depend;\n}","map":{"version":3,"names":["parentEntrySlot","hasOwnProperty","maybeUnsubscribe","arrayFromSet","EntryMethods","setDirty","dispose","forget","dep","options","depsByKey","Map","subscribe","depend","key","parent","getValue","get","set","Set","dependOn","unsubscribe","dirty","entryMethodName","m","call","forEach","entry","delete"],"sources":["C:\\bootcamp\\PICKFORD---LACE\\client\\node_modules\\optimism\\src\\dep.ts"],"sourcesContent":["import { AnyEntry } from \"./entry.js\";\r\nimport { OptimisticWrapOptions } from \"./index.js\";\r\nimport { parentEntrySlot } from \"./context.js\";\r\nimport {\r\n  hasOwnProperty,\r\n  Unsubscribable,\r\n  maybeUnsubscribe,\r\n  arrayFromSet,\r\n } from \"./helpers.js\";\r\n\r\ntype EntryMethodName = keyof typeof EntryMethods;\r\nconst EntryMethods = {\r\n  setDirty: true, // Mark parent Entry as needing to be recomputed (default)\r\n  dispose: true,  // Detach parent Entry from parents and children, but leave in LRU cache\r\n  forget: true,   // Fully remove parent Entry from LRU cache and computation graph\r\n};\r\n\r\nexport type OptimisticDependencyFunction<TKey> =\r\n  ((key: TKey) => void) & {\r\n    dirty: (key: TKey, entryMethodName?: EntryMethodName) => void;\r\n  };\r\n\r\nexport type Dep<TKey> = Set<AnyEntry> & {\r\n  subscribe: OptimisticWrapOptions<[TKey]>[\"subscribe\"];\r\n} & Unsubscribable;\r\n\r\nexport function dep<TKey>(options?: {\r\n  subscribe: Dep<TKey>[\"subscribe\"];\r\n}) {\r\n  const depsByKey = new Map<TKey, Dep<TKey>>();\r\n  const subscribe = options && options.subscribe;\r\n\r\n  function depend(key: TKey) {\r\n    const parent = parentEntrySlot.getValue();\r\n    if (parent) {\r\n      let dep = depsByKey.get(key);\r\n      if (!dep) {\r\n        depsByKey.set(key, dep = new Set as Dep<TKey>);\r\n      }\r\n      parent.dependOn(dep);\r\n      if (typeof subscribe === \"function\") {\r\n        maybeUnsubscribe(dep);\r\n        dep.unsubscribe = subscribe(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  depend.dirty = function dirty(\r\n    key: TKey,\r\n    entryMethodName?: EntryMethodName,\r\n  ) {\r\n    const dep = depsByKey.get(key);\r\n    if (dep) {\r\n      const m: EntryMethodName = (\r\n        entryMethodName &&\r\n        hasOwnProperty.call(EntryMethods, entryMethodName)\r\n      ) ? entryMethodName : \"setDirty\";\r\n      // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\r\n      // because modifying a Set while iterating over it can cause elements in\r\n      // the Set to be removed from the Set before they've been iterated over.\r\n      arrayFromSet(dep).forEach(entry => entry[m]());\r\n      depsByKey.delete(key);\r\n      maybeUnsubscribe(dep);\r\n    }\r\n  };\r\n\r\n  return depend as OptimisticDependencyFunction<TKey>;\r\n}\r\n"],"mappings":"AAEA,SAASA,eAAe,QAAQ,cAAc;AAC9C,SACEC,cAAc,EAEdC,gBAAgB,EAChBC,YAAY,QACN,cAAc;AAGtB,MAAMC,YAAY,GAAG;EACnBC,QAAQ,EAAE,IAAI;EACdC,OAAO,EAAE,IAAI;EACbC,MAAM,EAAE,IAAI,CAAI;CACjB;AAWD,OAAM,SAAUC,GAAGA,CAAOC,OAEzB;EACC,MAAMC,SAAS,GAAG,IAAIC,GAAG,EAAmB;EAC5C,MAAMC,SAAS,GAAGH,OAAO,IAAIA,OAAO,CAACG,SAAS;EAE9C,SAASC,MAAMA,CAACC,GAAS;IACvB,MAAMC,MAAM,GAAGf,eAAe,CAACgB,QAAQ,EAAE;IACzC,IAAID,MAAM,EAAE;MACV,IAAIP,GAAG,GAAGE,SAAS,CAACO,GAAG,CAACH,GAAG,CAAC;MAC5B,IAAI,CAACN,GAAG,EAAE;QACRE,SAAS,CAACQ,GAAG,CAACJ,GAAG,EAAEN,GAAG,GAAG,IAAIW,GAAgB,CAAhB,CAAgB,CAAC;;MAEhDJ,MAAM,CAACK,QAAQ,CAACZ,GAAG,CAAC;MACpB,IAAI,OAAOI,SAAS,KAAK,UAAU,EAAE;QACnCV,gBAAgB,CAACM,GAAG,CAAC;QACrBA,GAAG,CAACa,WAAW,GAAGT,SAAS,CAACE,GAAG,CAAC;;;EAGtC;EAEAD,MAAM,CAACS,KAAK,GAAG,SAASA,KAAKA,CAC3BR,GAAS,EACTS,eAAiC;IAEjC,MAAMf,GAAG,GAAGE,SAAS,CAACO,GAAG,CAACH,GAAG,CAAC;IAC9B,IAAIN,GAAG,EAAE;MACP,MAAMgB,CAAC,GACLD,eAAe,IACftB,cAAc,CAACwB,IAAI,CAACrB,YAAY,EAAEmB,eAAe,CAAC,GAChDA,eAAe,GAAG,UAAU;MAChC;MACA;MACA;MACApB,YAAY,CAACK,GAAG,CAAC,CAACkB,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACH,CAAC,CAAC,EAAE,CAAC;MAC9Cd,SAAS,CAACkB,MAAM,CAACd,GAAG,CAAC;MACrBZ,gBAAgB,CAACM,GAAG,CAAC;;EAEzB,CAAC;EAED,OAAOK,MAA4C;AACrD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}