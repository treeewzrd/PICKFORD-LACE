{"ast":null,"code":"import { didYouMean } from '../jsutils/didYouMean.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { suggestionList } from '../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { isInputObjectType, isLeafType, isListType, isNonNullType } from '../type/definition.mjs';\n\n/**\r\n * Coerces a JavaScript value given a GraphQL Input Type.\r\n */\nexport function coerceInputValue(inputValue, type, onError = defaultOnError) {\n  return coerceInputValueImpl(inputValue, type, onError, undefined);\n}\nfunction defaultOnError(path, invalidValue, error) {\n  let errorPrefix = 'Invalid value ' + inspect(invalidValue);\n  if (path.length > 0) {\n    errorPrefix += ` at \"value${printPathArray(path)}\"`;\n  }\n  error.message = errorPrefix + ': ' + error.message;\n  throw error;\n}\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\n  if (isNonNullType(type)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\n    }\n    onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type \"${inspect(type)}\" not to be null.`));\n    return;\n  }\n  if (inputValue == null) {\n    // Explicitly return the value null.\n    return null;\n  }\n  if (isListType(type)) {\n    const itemType = type.ofType;\n    if (isIterableObject(inputValue)) {\n      return Array.from(inputValue, (itemValue, index) => {\n        const itemPath = addPath(path, index, undefined);\n        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\n      });\n    } // Lists accept a non-list value as a list of one.\n\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\n  }\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(inputValue) || Array.isArray(inputValue)) {\n      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type \"${type.name}\" to be an object.`));\n      return;\n    }\n    const coercedValue = {};\n    const fieldDefs = type.getFields();\n    for (const field of Object.values(fieldDefs)) {\n      const fieldValue = inputValue[field.name];\n      if (fieldValue === undefined) {\n        if (field.defaultValue !== undefined) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          const typeStr = inspect(field.type);\n          onError(pathToArray(path), inputValue, new GraphQLError(`Field \"${field.name}\" of required type \"${typeStr}\" was not provided.`));\n        }\n        continue;\n      }\n      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type.name));\n    } // Ensure every provided field is defined.\n\n    for (const fieldName of Object.keys(inputValue)) {\n      if (!fieldDefs[fieldName]) {\n        const suggestions = suggestionList(fieldName, Object.keys(type.getFields()));\n        onError(pathToArray(path), inputValue, new GraphQLError(`Field \"${fieldName}\" is not defined by type \"${type.name}\".` + didYouMean(suggestions)));\n      }\n    }\n    if (type.isOneOf) {\n      const keys = Object.keys(coercedValue);\n      if (keys.length !== 1) {\n        onError(pathToArray(path), inputValue, new GraphQLError(`Exactly one key must be specified for OneOf type \"${type.name}\".`));\n      }\n      const key = keys[0];\n      const value = coercedValue[key];\n      if (value === null) {\n        onError(pathToArray(path).concat(key), value, new GraphQLError(`Field \"${key}\" must be non-null.`));\n      }\n    }\n    return coercedValue;\n  }\n  if (isLeafType(type)) {\n    let parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\n    // which can throw to indicate failure. If it throws, maintain a reference\n    // to the original error.\n\n    try {\n      parseResult = type.parseValue(inputValue);\n    } catch (error) {\n      if (error instanceof GraphQLError) {\n        onError(pathToArray(path), inputValue, error);\n      } else {\n        onError(pathToArray(path), inputValue, new GraphQLError(`Expected type \"${type.name}\". ` + error.message, {\n          originalError: error\n        }));\n      }\n      return;\n    }\n    if (parseResult === undefined) {\n      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type \"${type.name}\".`));\n    }\n    return parseResult;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\n}","map":{"version":3,"names":["didYouMean","inspect","invariant","isIterableObject","isObjectLike","addPath","pathToArray","printPathArray","suggestionList","GraphQLError","isInputObjectType","isLeafType","isListType","isNonNullType","coerceInputValue","inputValue","type","onError","defaultOnError","coerceInputValueImpl","undefined","path","invalidValue","error","errorPrefix","length","message","ofType","itemType","Array","from","itemValue","index","itemPath","isArray","name","coercedValue","fieldDefs","getFields","field","Object","values","fieldValue","defaultValue","typeStr","fieldName","keys","suggestions","isOneOf","key","value","concat","parseResult","parseValue","originalError"],"sources":["C:/bootcamp/PICKFORD---LACE/client/node_modules/graphql/utilities/coerceInputValue.mjs"],"sourcesContent":["import { didYouMean } from '../jsutils/didYouMean.mjs';\r\nimport { inspect } from '../jsutils/inspect.mjs';\r\nimport { invariant } from '../jsutils/invariant.mjs';\r\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\r\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\r\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\r\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\r\nimport { suggestionList } from '../jsutils/suggestionList.mjs';\r\nimport { GraphQLError } from '../error/GraphQLError.mjs';\r\nimport {\r\n  isInputObjectType,\r\n  isLeafType,\r\n  isListType,\r\n  isNonNullType,\r\n} from '../type/definition.mjs';\r\n\r\n/**\r\n * Coerces a JavaScript value given a GraphQL Input Type.\r\n */\r\nexport function coerceInputValue(inputValue, type, onError = defaultOnError) {\r\n  return coerceInputValueImpl(inputValue, type, onError, undefined);\r\n}\r\n\r\nfunction defaultOnError(path, invalidValue, error) {\r\n  let errorPrefix = 'Invalid value ' + inspect(invalidValue);\r\n\r\n  if (path.length > 0) {\r\n    errorPrefix += ` at \"value${printPathArray(path)}\"`;\r\n  }\r\n\r\n  error.message = errorPrefix + ': ' + error.message;\r\n  throw error;\r\n}\r\n\r\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\r\n  if (isNonNullType(type)) {\r\n    if (inputValue != null) {\r\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\r\n    }\r\n\r\n    onError(\r\n      pathToArray(path),\r\n      inputValue,\r\n      new GraphQLError(\r\n        `Expected non-nullable type \"${inspect(type)}\" not to be null.`,\r\n      ),\r\n    );\r\n    return;\r\n  }\r\n\r\n  if (inputValue == null) {\r\n    // Explicitly return the value null.\r\n    return null;\r\n  }\r\n\r\n  if (isListType(type)) {\r\n    const itemType = type.ofType;\r\n\r\n    if (isIterableObject(inputValue)) {\r\n      return Array.from(inputValue, (itemValue, index) => {\r\n        const itemPath = addPath(path, index, undefined);\r\n        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\r\n      });\r\n    } // Lists accept a non-list value as a list of one.\r\n\r\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\r\n  }\r\n\r\n  if (isInputObjectType(type)) {\r\n    if (!isObjectLike(inputValue) || Array.isArray(inputValue)) {\r\n      onError(\r\n        pathToArray(path),\r\n        inputValue,\r\n        new GraphQLError(`Expected type \"${type.name}\" to be an object.`),\r\n      );\r\n      return;\r\n    }\r\n\r\n    const coercedValue = {};\r\n    const fieldDefs = type.getFields();\r\n\r\n    for (const field of Object.values(fieldDefs)) {\r\n      const fieldValue = inputValue[field.name];\r\n\r\n      if (fieldValue === undefined) {\r\n        if (field.defaultValue !== undefined) {\r\n          coercedValue[field.name] = field.defaultValue;\r\n        } else if (isNonNullType(field.type)) {\r\n          const typeStr = inspect(field.type);\r\n          onError(\r\n            pathToArray(path),\r\n            inputValue,\r\n            new GraphQLError(\r\n              `Field \"${field.name}\" of required type \"${typeStr}\" was not provided.`,\r\n            ),\r\n          );\r\n        }\r\n\r\n        continue;\r\n      }\r\n\r\n      coercedValue[field.name] = coerceInputValueImpl(\r\n        fieldValue,\r\n        field.type,\r\n        onError,\r\n        addPath(path, field.name, type.name),\r\n      );\r\n    } // Ensure every provided field is defined.\r\n\r\n    for (const fieldName of Object.keys(inputValue)) {\r\n      if (!fieldDefs[fieldName]) {\r\n        const suggestions = suggestionList(\r\n          fieldName,\r\n          Object.keys(type.getFields()),\r\n        );\r\n        onError(\r\n          pathToArray(path),\r\n          inputValue,\r\n          new GraphQLError(\r\n            `Field \"${fieldName}\" is not defined by type \"${type.name}\".` +\r\n              didYouMean(suggestions),\r\n          ),\r\n        );\r\n      }\r\n    }\r\n\r\n    if (type.isOneOf) {\r\n      const keys = Object.keys(coercedValue);\r\n\r\n      if (keys.length !== 1) {\r\n        onError(\r\n          pathToArray(path),\r\n          inputValue,\r\n          new GraphQLError(\r\n            `Exactly one key must be specified for OneOf type \"${type.name}\".`,\r\n          ),\r\n        );\r\n      }\r\n\r\n      const key = keys[0];\r\n      const value = coercedValue[key];\r\n\r\n      if (value === null) {\r\n        onError(\r\n          pathToArray(path).concat(key),\r\n          value,\r\n          new GraphQLError(`Field \"${key}\" must be non-null.`),\r\n        );\r\n      }\r\n    }\r\n\r\n    return coercedValue;\r\n  }\r\n\r\n  if (isLeafType(type)) {\r\n    let parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\r\n    // which can throw to indicate failure. If it throws, maintain a reference\r\n    // to the original error.\r\n\r\n    try {\r\n      parseResult = type.parseValue(inputValue);\r\n    } catch (error) {\r\n      if (error instanceof GraphQLError) {\r\n        onError(pathToArray(path), inputValue, error);\r\n      } else {\r\n        onError(\r\n          pathToArray(path),\r\n          inputValue,\r\n          new GraphQLError(`Expected type \"${type.name}\". ` + error.message, {\r\n            originalError: error,\r\n          }),\r\n        );\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (parseResult === undefined) {\r\n      onError(\r\n        pathToArray(path),\r\n        inputValue,\r\n        new GraphQLError(`Expected type \"${type.name}\".`),\r\n      );\r\n    }\r\n\r\n    return parseResult;\r\n  }\r\n  /* c8 ignore next 3 */\r\n  // Not reachable, all possible types have been considered.\r\n\r\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}