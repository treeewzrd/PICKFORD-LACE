{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { createFulfilledPromise, wrapPromiseWithState } from \"../../../utilities/index.js\";\nvar FragmentReference = /** @class */function () {\n  function FragmentReference(client, watchFragmentOptions, options) {\n    var _this = this;\n    this.key = {};\n    this.listeners = new Set();\n    this.references = 0;\n    this.dispose = this.dispose.bind(this);\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.observable = client.watchFragment(watchFragmentOptions);\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n    var diff = this.getDiff(client, watchFragmentOptions);\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this fragmentRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    var startDisposeTimer = function () {\n      var _a;\n      if (!_this.references) {\n        _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n      }\n    };\n    this.promise = diff.complete ? createFulfilledPromise(diff.result) : this.createPendingPromise();\n    this.subscribeToFragment();\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n  FragmentReference.prototype.listen = function (listener) {\n    var _this = this;\n    this.listeners.add(listener);\n    return function () {\n      _this.listeners.delete(listener);\n    };\n  };\n  FragmentReference.prototype.retain = function () {\n    var _this = this;\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    var disposed = false;\n    return function () {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      _this.references--;\n      setTimeout(function () {\n        if (!_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n  FragmentReference.prototype.dispose = function () {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  };\n  FragmentReference.prototype.onDispose = function () {\n    // noop. overridable by options\n  };\n  FragmentReference.prototype.subscribeToFragment = function () {\n    this.subscription = this.observable.subscribe(this.handleNext.bind(this), this.handleError.bind(this));\n  };\n  FragmentReference.prototype.handleNext = function (result) {\n    var _a;\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          if (result.complete) {\n            return (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result.data);\n          }\n          this.deliver(this.promise);\n          break;\n        }\n      case \"fulfilled\":\n        {\n          // This can occur when we already have a result written to the cache and\n          // we subscribe for the first time. We create a fulfilled promise in the\n          // constructor with a value that is the same as the first emitted value\n          // so we want to skip delivering it.\n          if (equal(this.promise.value, result.data)) {\n            return;\n          }\n          this.promise = result.complete ? createFulfilledPromise(result.data) : this.createPendingPromise();\n          this.deliver(this.promise);\n        }\n    }\n  };\n  FragmentReference.prototype.handleError = function (error) {\n    var _a;\n    (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n  };\n  FragmentReference.prototype.deliver = function (promise) {\n    this.listeners.forEach(function (listener) {\n      return listener(promise);\n    });\n  };\n  FragmentReference.prototype.createPendingPromise = function () {\n    var _this = this;\n    return wrapPromiseWithState(new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    }));\n  };\n  FragmentReference.prototype.getDiff = function (client, options) {\n    var cache = client.cache;\n    var from = options.from,\n      fragment = options.fragment,\n      fragmentName = options.fragmentName;\n    var diff = cache.diff(__assign(__assign({}, options), {\n      query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n      returnPartialData: true,\n      id: from,\n      optimistic: true\n    }));\n    return __assign(__assign({}, diff), {\n      result: client[\"queryManager\"].maskFragment({\n        fragment: fragment,\n        fragmentName: fragmentName,\n        data: diff.result\n      })\n    });\n  };\n  return FragmentReference;\n}();\nexport { FragmentReference };","map":{"version":3,"names":["equal","createFulfilledPromise","wrapPromiseWithState","FragmentReference","client","watchFragmentOptions","options","_this","key","listeners","Set","references","dispose","bind","handleNext","handleError","observable","watchFragment","onDispose","diff","getDiff","startDisposeTimer","autoDisposeTimeoutId","setTimeout","_a","autoDisposeTimeoutMs","promise","complete","result","createPendingPromise","subscribeToFragment","then","prototype","listen","listener","add","delete","retain","clearTimeout","disposed","subscription","unsubscribe","subscribe","status","resolve","call","data","deliver","value","error","reject","forEach","Promise","cache","from","fragment","fragmentName","__assign","query","returnPartialData","id","optimistic","maskFragment"],"sources":["C:\\bootcamp\\PICKFORD---LACE\\client\\node_modules\\@apollo\\src\\react\\internal\\cache\\FragmentReference.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type {\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../../../cache/index.js\";\nimport type { ApolloClient } from \"../../../core/ApolloClient.js\";\nimport type { MaybeMasked } from \"../../../masking/index.js\";\nimport {\n  createFulfilledPromise,\n  wrapPromiseWithState,\n} from \"../../../utilities/index.js\";\nimport type {\n  Observable,\n  ObservableSubscription,\n  PromiseWithState,\n} from \"../../../utilities/index.js\";\nimport type { FragmentKey } from \"./types.js\";\n\ntype FragmentRefPromise<TData> = PromiseWithState<TData>;\ntype Listener<TData> = (promise: FragmentRefPromise<TData>) => void;\n\ninterface FragmentReferenceOptions {\n  autoDisposeTimeoutMs?: number;\n  onDispose?: () => void;\n}\n\nexport class FragmentReference<\n  TData = unknown,\n  TVariables = Record<string, unknown>,\n> {\n  public readonly observable: Observable<WatchFragmentResult<TData>>;\n  public readonly key: FragmentKey = {};\n  public promise!: FragmentRefPromise<MaybeMasked<TData>>;\n\n  private resolve: ((result: MaybeMasked<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private subscription!: ObservableSubscription;\n  private listeners = new Set<Listener<MaybeMasked<TData>>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private references = 0;\n\n  constructor(\n    client: ApolloClient<any>,\n    watchFragmentOptions: WatchFragmentOptions<TData, TVariables> & {\n      from: string;\n    },\n    options: FragmentReferenceOptions\n  ) {\n    this.dispose = this.dispose.bind(this);\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n\n    this.observable = client.watchFragment(watchFragmentOptions);\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    const diff = this.getDiff(client, watchFragmentOptions);\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this fragmentRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    this.promise =\n      diff.complete ?\n        createFulfilledPromise(diff.result)\n      : this.createPendingPromise();\n    this.subscribeToFragment();\n\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  listen(listener: Listener<MaybeMasked<TData>>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private subscribeToFragment() {\n    this.subscription = this.observable.subscribe(\n      this.handleNext.bind(this),\n      this.handleError.bind(this)\n    );\n  }\n\n  private handleNext(result: WatchFragmentResult<TData>) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        if (result.complete) {\n          return this.resolve?.(result.data);\n        }\n\n        this.deliver(this.promise);\n        break;\n      }\n      case \"fulfilled\": {\n        // This can occur when we already have a result written to the cache and\n        // we subscribe for the first time. We create a fulfilled promise in the\n        // constructor with a value that is the same as the first emitted value\n        // so we want to skip delivering it.\n        if (equal(this.promise.value, result.data)) {\n          return;\n        }\n\n        this.promise =\n          result.complete ?\n            createFulfilledPromise(result.data)\n          : this.createPendingPromise();\n\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private handleError(error: unknown) {\n    this.reject?.(error);\n  }\n\n  private deliver(promise: FragmentRefPromise<MaybeMasked<TData>>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private createPendingPromise() {\n    return wrapPromiseWithState(\n      new Promise<MaybeMasked<TData>>((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      })\n    );\n  }\n\n  private getDiff<TData, TVariables>(\n    client: ApolloClient<any>,\n    options: WatchFragmentOptions<TData, TVariables> & { from: string }\n  ) {\n    const { cache } = client;\n    const { from, fragment, fragmentName } = options;\n\n    const diff = cache.diff({\n      ...options,\n      query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n      returnPartialData: true,\n      id: from,\n      optimistic: true,\n    });\n\n    return {\n      ...diff,\n      result: client[\"queryManager\"].maskFragment({\n        fragment,\n        fragmentName,\n        data: diff.result,\n      }) as MaybeMasked<TData>,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}