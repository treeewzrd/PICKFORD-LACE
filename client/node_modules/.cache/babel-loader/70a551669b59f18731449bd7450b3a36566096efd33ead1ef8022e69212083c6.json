{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { getNamedType, isInputObjectType, isInterfaceType, isObjectType, isUnionType } from './definition.mjs';\nimport { isDirective, specifiedDirectives } from './directives.mjs';\nimport { __Schema } from './introspection.mjs';\n/**\r\n * Test if the given value is a GraphQL schema.\r\n */\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);\n  }\n  return schema;\n}\n/**\r\n * Custom extensions\r\n *\r\n * @remarks\r\n * Use a unique identifier name for your extension, for example the name of\r\n * your library or project. Do not use a shortened identifier as this increases\r\n * the risk of conflicts. We recommend you add at most one extension field,\r\n * an object which can contain all the values you need.\r\n */\n\n/**\r\n * Schema Definition\r\n *\r\n * A Schema is created by supplying the root types of each type of operation,\r\n * query and mutation (optional). A schema definition is then supplied to the\r\n * validator and executor.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * const MyAppSchema = new GraphQLSchema({\r\n *   query: MyAppQueryRootType,\r\n *   mutation: MyAppMutationRootType,\r\n * })\r\n * ```\r\n *\r\n * Note: When the schema is constructed, by default only the types that are\r\n * reachable by traversing the root types are included, other types must be\r\n * explicitly referenced.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * const characterInterface = new GraphQLInterfaceType({\r\n *   name: 'Character',\r\n *   ...\r\n * });\r\n *\r\n * const humanType = new GraphQLObjectType({\r\n *   name: 'Human',\r\n *   interfaces: [characterInterface],\r\n *   ...\r\n * });\r\n *\r\n * const droidType = new GraphQLObjectType({\r\n *   name: 'Droid',\r\n *   interfaces: [characterInterface],\r\n *   ...\r\n * });\r\n *\r\n * const schema = new GraphQLSchema({\r\n *   query: new GraphQLObjectType({\r\n *     name: 'Query',\r\n *     fields: {\r\n *       hero: { type: characterInterface, ... },\r\n *     }\r\n *   }),\r\n *   ...\r\n *   // Since this schema references only the `Character` interface it's\r\n *   // necessary to explicitly list the types that implement it if\r\n *   // you want them to be included in the final schema.\r\n *   types: [humanType, droidType],\r\n * })\r\n * ```\r\n *\r\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\r\n * the exact list of directives represented and allowed. If `directives` is not\r\n * provided then a default set of the specified directives (e.g. `@include` and\r\n * `@skip`) will be used. If you wish to provide *additional* directives to these\r\n * specified directives, you must explicitly declare them. Example:\r\n *\r\n * ```ts\r\n * const MyAppSchema = new GraphQLSchema({\r\n *   ...\r\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\r\n * })\r\n * ```\r\n */\nexport class GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) || devAssert(false, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || devAssert(false, `\"types\" must be Array if provided but got: ${inspect(config.types)}.`);\n    !config.directives || Array.isArray(config.directives) || devAssert(false, '\"directives\" must be Array if provided but got: ' + `${inspect(config.directives)}.`);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if (isDirective(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n      const typeName = namedType.name;\n      typeName || devAssert(false, 'One of the provided types for building the Schema is missing a name.');\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(`Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`);\n      }\n      this._typeMap[typeName] = namedType;\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n  getQueryType() {\n    return this._queryType;\n  }\n  getMutationType() {\n    return this._mutationType;\n  }\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n  getRootType(operation) {\n    switch (operation) {\n      case OperationTypeNode.QUERY:\n        return this.getQueryType();\n      case OperationTypeNode.MUTATION:\n        return this.getMutationType();\n      case OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n  getTypeMap() {\n    return this._typeMap;\n  }\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n  getPossibleTypes(abstractType) {\n    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n  }\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0 ? implementations : {\n      objects: [],\n      interfaces: []\n    };\n  }\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n    if (map === undefined) {\n      map = Object.create(null);\n      if (isUnionType(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n      this._subTypeMap[abstractType.name] = map;\n    }\n    return map[maybeSubType.name] !== undefined;\n  }\n  getDirectives() {\n    return this._directives;\n  }\n  getDirective(name) {\n    return this.getDirectives().find(directive => directive.name === name);\n  }\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined\n    };\n  }\n}\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = getNamedType(type);\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n    if (isUnionType(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n  return typeSet;\n}","map":{"version":3,"names":["devAssert","inspect","instanceOf","isObjectLike","toObjMap","OperationTypeNode","getNamedType","isInputObjectType","isInterfaceType","isObjectType","isUnionType","isDirective","specifiedDirectives","__Schema","isSchema","schema","GraphQLSchema","assertSchema","Error","constructor","config","_config$extensionASTN","_config$directives","__validationErrors","assumeValid","undefined","types","Array","isArray","directives","description","extensions","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","allReferencedTypes","Set","type","delete","collectReferencedTypes","directive","arg","args","_typeMap","Object","create","_subTypeMap","_implementationsMap","namedType","typeName","name","iface","getInterfaces","implementations","objects","interfaces","push","Symbol","toStringTag","getQueryType","getMutationType","getSubscriptionType","getRootType","operation","QUERY","MUTATION","SUBSCRIPTION","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","getImplementations","interfaceType","isSubType","maybeSubType","map","getDirectives","getDirective","find","toConfig","values","typeSet","has","add","memberType","field","getFields"],"sources":["C:/bootcamp/PICKFORD---LACE/client/node_modules/graphql/type/schema.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\r\nimport { inspect } from '../jsutils/inspect.mjs';\r\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\r\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\r\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\r\nimport { OperationTypeNode } from '../language/ast.mjs';\r\nimport {\r\n  getNamedType,\r\n  isInputObjectType,\r\n  isInterfaceType,\r\n  isObjectType,\r\n  isUnionType,\r\n} from './definition.mjs';\r\nimport { isDirective, specifiedDirectives } from './directives.mjs';\r\nimport { __Schema } from './introspection.mjs';\r\n/**\r\n * Test if the given value is a GraphQL schema.\r\n */\r\n\r\nexport function isSchema(schema) {\r\n  return instanceOf(schema, GraphQLSchema);\r\n}\r\nexport function assertSchema(schema) {\r\n  if (!isSchema(schema)) {\r\n    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);\r\n  }\r\n\r\n  return schema;\r\n}\r\n/**\r\n * Custom extensions\r\n *\r\n * @remarks\r\n * Use a unique identifier name for your extension, for example the name of\r\n * your library or project. Do not use a shortened identifier as this increases\r\n * the risk of conflicts. We recommend you add at most one extension field,\r\n * an object which can contain all the values you need.\r\n */\r\n\r\n/**\r\n * Schema Definition\r\n *\r\n * A Schema is created by supplying the root types of each type of operation,\r\n * query and mutation (optional). A schema definition is then supplied to the\r\n * validator and executor.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * const MyAppSchema = new GraphQLSchema({\r\n *   query: MyAppQueryRootType,\r\n *   mutation: MyAppMutationRootType,\r\n * })\r\n * ```\r\n *\r\n * Note: When the schema is constructed, by default only the types that are\r\n * reachable by traversing the root types are included, other types must be\r\n * explicitly referenced.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * const characterInterface = new GraphQLInterfaceType({\r\n *   name: 'Character',\r\n *   ...\r\n * });\r\n *\r\n * const humanType = new GraphQLObjectType({\r\n *   name: 'Human',\r\n *   interfaces: [characterInterface],\r\n *   ...\r\n * });\r\n *\r\n * const droidType = new GraphQLObjectType({\r\n *   name: 'Droid',\r\n *   interfaces: [characterInterface],\r\n *   ...\r\n * });\r\n *\r\n * const schema = new GraphQLSchema({\r\n *   query: new GraphQLObjectType({\r\n *     name: 'Query',\r\n *     fields: {\r\n *       hero: { type: characterInterface, ... },\r\n *     }\r\n *   }),\r\n *   ...\r\n *   // Since this schema references only the `Character` interface it's\r\n *   // necessary to explicitly list the types that implement it if\r\n *   // you want them to be included in the final schema.\r\n *   types: [humanType, droidType],\r\n * })\r\n * ```\r\n *\r\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\r\n * the exact list of directives represented and allowed. If `directives` is not\r\n * provided then a default set of the specified directives (e.g. `@include` and\r\n * `@skip`) will be used. If you wish to provide *additional* directives to these\r\n * specified directives, you must explicitly declare them. Example:\r\n *\r\n * ```ts\r\n * const MyAppSchema = new GraphQLSchema({\r\n *   ...\r\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\r\n * })\r\n * ```\r\n */\r\nexport class GraphQLSchema {\r\n  // Used as a cache for validateSchema().\r\n  constructor(config) {\r\n    var _config$extensionASTN, _config$directives;\r\n\r\n    // If this schema was built from a source known to be valid, then it may be\r\n    // marked with assumeValid to avoid an additional type system validation.\r\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\r\n\r\n    isObjectLike(config) ||\r\n      devAssert(false, 'Must provide configuration object.');\r\n    !config.types ||\r\n      Array.isArray(config.types) ||\r\n      devAssert(\r\n        false,\r\n        `\"types\" must be Array if provided but got: ${inspect(config.types)}.`,\r\n      );\r\n    !config.directives ||\r\n      Array.isArray(config.directives) ||\r\n      devAssert(\r\n        false,\r\n        '\"directives\" must be Array if provided but got: ' +\r\n          `${inspect(config.directives)}.`,\r\n      );\r\n    this.description = config.description;\r\n    this.extensions = toObjMap(config.extensions);\r\n    this.astNode = config.astNode;\r\n    this.extensionASTNodes =\r\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\r\n      _config$extensionASTN !== void 0\r\n        ? _config$extensionASTN\r\n        : [];\r\n    this._queryType = config.query;\r\n    this._mutationType = config.mutation;\r\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\r\n\r\n    this._directives =\r\n      (_config$directives = config.directives) !== null &&\r\n      _config$directives !== void 0\r\n        ? _config$directives\r\n        : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\r\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\r\n\r\n    const allReferencedTypes = new Set(config.types);\r\n\r\n    if (config.types != null) {\r\n      for (const type of config.types) {\r\n        // When we ready to process this type, we remove it from \"collected\" types\r\n        // and then add it together with all dependent types in the correct position.\r\n        allReferencedTypes.delete(type);\r\n        collectReferencedTypes(type, allReferencedTypes);\r\n      }\r\n    }\r\n\r\n    if (this._queryType != null) {\r\n      collectReferencedTypes(this._queryType, allReferencedTypes);\r\n    }\r\n\r\n    if (this._mutationType != null) {\r\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\r\n    }\r\n\r\n    if (this._subscriptionType != null) {\r\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\r\n    }\r\n\r\n    for (const directive of this._directives) {\r\n      // Directives are not validated until validateSchema() is called.\r\n      if (isDirective(directive)) {\r\n        for (const arg of directive.args) {\r\n          collectReferencedTypes(arg.type, allReferencedTypes);\r\n        }\r\n      }\r\n    }\r\n\r\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\r\n\r\n    this._typeMap = Object.create(null);\r\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\r\n\r\n    this._implementationsMap = Object.create(null);\r\n\r\n    for (const namedType of allReferencedTypes) {\r\n      if (namedType == null) {\r\n        continue;\r\n      }\r\n\r\n      const typeName = namedType.name;\r\n      typeName ||\r\n        devAssert(\r\n          false,\r\n          'One of the provided types for building the Schema is missing a name.',\r\n        );\r\n\r\n      if (this._typeMap[typeName] !== undefined) {\r\n        throw new Error(\r\n          `Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`,\r\n        );\r\n      }\r\n\r\n      this._typeMap[typeName] = namedType;\r\n\r\n      if (isInterfaceType(namedType)) {\r\n        // Store implementations by interface.\r\n        for (const iface of namedType.getInterfaces()) {\r\n          if (isInterfaceType(iface)) {\r\n            let implementations = this._implementationsMap[iface.name];\r\n\r\n            if (implementations === undefined) {\r\n              implementations = this._implementationsMap[iface.name] = {\r\n                objects: [],\r\n                interfaces: [],\r\n              };\r\n            }\r\n\r\n            implementations.interfaces.push(namedType);\r\n          }\r\n        }\r\n      } else if (isObjectType(namedType)) {\r\n        // Store implementations by objects.\r\n        for (const iface of namedType.getInterfaces()) {\r\n          if (isInterfaceType(iface)) {\r\n            let implementations = this._implementationsMap[iface.name];\r\n\r\n            if (implementations === undefined) {\r\n              implementations = this._implementationsMap[iface.name] = {\r\n                objects: [],\r\n                interfaces: [],\r\n              };\r\n            }\r\n\r\n            implementations.objects.push(namedType);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'GraphQLSchema';\r\n  }\r\n\r\n  getQueryType() {\r\n    return this._queryType;\r\n  }\r\n\r\n  getMutationType() {\r\n    return this._mutationType;\r\n  }\r\n\r\n  getSubscriptionType() {\r\n    return this._subscriptionType;\r\n  }\r\n\r\n  getRootType(operation) {\r\n    switch (operation) {\r\n      case OperationTypeNode.QUERY:\r\n        return this.getQueryType();\r\n\r\n      case OperationTypeNode.MUTATION:\r\n        return this.getMutationType();\r\n\r\n      case OperationTypeNode.SUBSCRIPTION:\r\n        return this.getSubscriptionType();\r\n    }\r\n  }\r\n\r\n  getTypeMap() {\r\n    return this._typeMap;\r\n  }\r\n\r\n  getType(name) {\r\n    return this.getTypeMap()[name];\r\n  }\r\n\r\n  getPossibleTypes(abstractType) {\r\n    return isUnionType(abstractType)\r\n      ? abstractType.getTypes()\r\n      : this.getImplementations(abstractType).objects;\r\n  }\r\n\r\n  getImplementations(interfaceType) {\r\n    const implementations = this._implementationsMap[interfaceType.name];\r\n    return implementations !== null && implementations !== void 0\r\n      ? implementations\r\n      : {\r\n          objects: [],\r\n          interfaces: [],\r\n        };\r\n  }\r\n\r\n  isSubType(abstractType, maybeSubType) {\r\n    let map = this._subTypeMap[abstractType.name];\r\n\r\n    if (map === undefined) {\r\n      map = Object.create(null);\r\n\r\n      if (isUnionType(abstractType)) {\r\n        for (const type of abstractType.getTypes()) {\r\n          map[type.name] = true;\r\n        }\r\n      } else {\r\n        const implementations = this.getImplementations(abstractType);\r\n\r\n        for (const type of implementations.objects) {\r\n          map[type.name] = true;\r\n        }\r\n\r\n        for (const type of implementations.interfaces) {\r\n          map[type.name] = true;\r\n        }\r\n      }\r\n\r\n      this._subTypeMap[abstractType.name] = map;\r\n    }\r\n\r\n    return map[maybeSubType.name] !== undefined;\r\n  }\r\n\r\n  getDirectives() {\r\n    return this._directives;\r\n  }\r\n\r\n  getDirective(name) {\r\n    return this.getDirectives().find((directive) => directive.name === name);\r\n  }\r\n\r\n  toConfig() {\r\n    return {\r\n      description: this.description,\r\n      query: this.getQueryType(),\r\n      mutation: this.getMutationType(),\r\n      subscription: this.getSubscriptionType(),\r\n      types: Object.values(this.getTypeMap()),\r\n      directives: this.getDirectives(),\r\n      extensions: this.extensions,\r\n      astNode: this.astNode,\r\n      extensionASTNodes: this.extensionASTNodes,\r\n      assumeValid: this.__validationErrors !== undefined,\r\n    };\r\n  }\r\n}\r\n\r\nfunction collectReferencedTypes(type, typeSet) {\r\n  const namedType = getNamedType(type);\r\n\r\n  if (!typeSet.has(namedType)) {\r\n    typeSet.add(namedType);\r\n\r\n    if (isUnionType(namedType)) {\r\n      for (const memberType of namedType.getTypes()) {\r\n        collectReferencedTypes(memberType, typeSet);\r\n      }\r\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\r\n      for (const interfaceType of namedType.getInterfaces()) {\r\n        collectReferencedTypes(interfaceType, typeSet);\r\n      }\r\n\r\n      for (const field of Object.values(namedType.getFields())) {\r\n        collectReferencedTypes(field.type, typeSet);\r\n\r\n        for (const arg of field.args) {\r\n          collectReferencedTypes(arg.type, typeSet);\r\n        }\r\n      }\r\n    } else if (isInputObjectType(namedType)) {\r\n      for (const field of Object.values(namedType.getFields())) {\r\n        collectReferencedTypes(field.type, typeSet);\r\n      }\r\n    }\r\n  }\r\n\r\n  return typeSet;\r\n}\r\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,0BAA0B;AACpD,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,UAAU,QAAQ,2BAA2B;AACtD,SAASC,YAAY,QAAQ,6BAA6B;AAC1D,SAASC,QAAQ,QAAQ,yBAAyB;AAClD,SAASC,iBAAiB,QAAQ,qBAAqB;AACvD,SACEC,YAAY,EACZC,iBAAiB,EACjBC,eAAe,EACfC,YAAY,EACZC,WAAW,QACN,kBAAkB;AACzB,SAASC,WAAW,EAAEC,mBAAmB,QAAQ,kBAAkB;AACnE,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C;AACA;AACA;;AAEA,OAAO,SAASC,QAAQA,CAACC,MAAM,EAAE;EAC/B,OAAOb,UAAU,CAACa,MAAM,EAAEC,aAAa,CAAC;AAC1C;AACA,OAAO,SAASC,YAAYA,CAACF,MAAM,EAAE;EACnC,IAAI,CAACD,QAAQ,CAACC,MAAM,CAAC,EAAE;IACrB,MAAM,IAAIG,KAAK,CAAC,YAAYjB,OAAO,CAACc,MAAM,CAAC,0BAA0B,CAAC;EACxE;EAEA,OAAOA,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,CAAC;EACzB;EACAG,WAAWA,CAACC,MAAM,EAAE;IAClB,IAAIC,qBAAqB,EAAEC,kBAAkB;;IAE7C;IACA;IACA,IAAI,CAACC,kBAAkB,GAAGH,MAAM,CAACI,WAAW,KAAK,IAAI,GAAG,EAAE,GAAGC,SAAS,CAAC,CAAC;;IAExEtB,YAAY,CAACiB,M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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}